{"greeting": "Greetings from The On-Line Encyclopedia of Integer Sequences! http://oeis.org/", "query": "id:A193403", "count": 1, "start": 0, "results": [{"number": 193403, "data": "0,1,-1,0,1,0,-2,0,1,0,-2,0,1,1,0,-3,0,1,1,0,-3,0,1,0,0,-3,0,1,0,0,-3,0,1,0,3,0,-4,0,1,0,3,0,-4,0,1,0,3,0,-4,0,1,0,2,0,-4,0,1,0,2,0,-4,0,1,0,2,0,-4,0,1,-1,0,6,0,-5,0,1,0,0,0,-4,0,1,0,2,0,-4,0,1,-1,0,5,0,-5,0,1,0,0,0,-4,0,1", "name": "Triangle read by rows: row n contains the coefficients (of the increasing powers of the variable x) of the matching polynomial of the rooted tree having Matula-Goebel number n.", "comment": ["Row n contains 1+A061775(n) entries (= 1 + number of vertices of the rooted tree).", "The Matula-Goebel number of a rooted tree can be defined in the following recursive manner: to the one-vertex tree there corresponds the number 1; to a tree T with root degree 1 there corresponds the t-th prime number, where t is the Matula-Goebel number of the tree obtained from T by deleting the edge emanating from the root; to a tree T with root degree m>=2 there corresponds the product of the Matula-Goebel numbers of the m branches of T.", "After activating the Maple program, the command mm(n) will yield the matching polynomial of the rooted tree corresponding to the Matula-Goebel number n."], "reference": ["F. Goebel, On a 1-1-correspondence between rooted trees and natural numbers, J. Combin. Theory, B 29 (1980), 141-143.", "I. Gutman and A. Ivic, On Matula numbers, Discrete Math., 150, 1996, 131-142.", "I. Gutman and Yeong-Nan Yeh, Deducing properties of trees from their Matula numbers, Publ. Inst. Math., 53 (67), 1993, 17-22.", "D. W. Matula, A natural rooted tree enumeration by prime factorization, SIAM Review, 10, 1968, 273.", "\u00c9. Czabarka, L. Sz\u00e9kely, and S. Wagner, The inverse problem for certain tree parameters, Discrete Appl. Math., 157, 2009, 3314-3319.", "C. D. Godsil, Algebraic Combinatorics, Chapman & Hall, New York, 1993."], "link": ["E. Deutsch, <a href=\"http://arxiv.org/abs/1111.4288\"> Rooted tree statistics from Matula numbers</a>, arXiv:1111.4288 [math.CO], 2011.", "<a href=\"/index/Mat#matula\">Index entries for sequences related to Matula-Goebel numbers</a>"], "formula": ["Define b(n) (c(n)) to be the generating polynomials of the matchings of the rooted tree with Matula-Goebel number n that contain (do not contain) the root, with respect to the size of the matching. We have the following recurrence for the pair M(n)=[b(n),c(n)]. M(1)=[0,1]; if n=p(t) (=the t-th prime), then M(n)=[xc(t),b(t)+c(t)]; if n=rs (r,s,>=2), then M(n)=[b(r)c(s)+c(r)b(s), c(r)c(s)]. Then m(n)=b(n)+c(n) is the generating polynomial of the matchings of the rooted tree with respect to the size of the matchings (a modified matching polynomial). The actual matching polynomial is obtained by the substitution x = -1/x^2, followed by multiplication by x^N(n), where N(n) is the number of vertices of the rooted tree."], "maple": ["with(numtheory): N := proc (n) local r, s: r := proc (n) options operator, arrow: op(1, factorset(n)) end proc: s := proc (n) options operator, arrow: n/r(n) end proc: if n = 1 then 1 elif bigomega(n) = 1 then 1+N(pi(n)) else N(r(n))+N(s(n))-1 end if end proc: M := proc (n) local r, s: r := proc (n) options operator, arrow: op(1, factorset(n)) end proc: s := proc (n) options operator, arrow: n/r(n) end proc: if n = 1 then [0, 1] elif bigomega(n) = 1 then [x*M(pi(n))[2], M(pi(n))[1]+M(pi(n))[2]] else [M(r(n))[1]*M(s(n))[2]+M(r(n))[2]*M(s(n))[1], M(r(n))[2]*M(s(n))[2]] end if end proc: m := proc (n) options operator, arrow: sort(expand(M(n)[1]+M(n)[2])) end proc: mm := proc (n) options operator, arrow: sort(expand(x^N(n)*subs(x = -1/x^2, m(n)))) end proc: for n to 19 do seq(coeff(mm(n), x, j), j = 0 .. N(n)) end do; # yields sequence in triangular form"], "program": ["(Sage)", "def M(n) :", "    if n == 1 : return [0, 1, 1]", "    if 1 == sloane.A001222(n) : # bigomega", "        mpi = M(prime_pi(n))", "        return [x*mpi[1], mpi[0]+mpi[1], 1+mpi[2]]", "    r = max(prime_divisors(n)); mr = M(r); ms = M(n//r)", "    return [mr[0]*ms[1]+mr[1]*ms[0],mr[1]*ms[1],mr[2]+ms[2]-1]", "def A193403_coeffs(n) :", "    mn = M(n)", "    q = (mn[0]+mn[1]).subs(x=-1/x^2)", "    p = expand(x^mn[2]*q)", "    return coefficient_list(p, x)", "for n in (1..19) : print(A193403_coeffs(n))  # Peter Luschny, Feb 12 2012"], "xref": ["Cf. A061775."], "keyword": "sign,tabf", "offset": "1,7", "author": "_Emeric Deutsch_, Feb 12 2012", "references": 4, "revision": 22, "time": "2020-03-07T08:52:15-05:00", "created": "2012-02-13T11:22:18-05:00"}]}