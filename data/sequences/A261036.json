{"greeting": "Greetings from The On-Line Encyclopedia of Integer Sequences! http://oeis.org/", "query": "id:A261036", "count": 1, "start": 0, "results": [{"number": 261036, "data": "1,1,1,1,1,1,1,2,1,1,2,2,1,3,2,2,1,3,4,2,1,4,5,4,2,1,4,6,5,4,1,5,8,8,5,4,1,5,10,10,8,5,1,6,11,14,10,8,5,1,6,14,16,16,10,8,1,7,16,22,20,16,10,8,1,7,18,26,27,20,16,10,1,8,21,32,34,31", "name": "Table read by rows: number of complete partitions of n with largest part = k.", "comment": ["See A126796 for definition of complete partitions;", "A126796(n) = sum of n-th row;", "also T(n,floor((n+1)/2) = A126796(floor(n/2))."], "link": ["Reinhard Zumkeller, <a href=\"/A261036/b261036.txt\">Rows n = 1..200 of triangle, flattened</a>", "SeungKyung Park, <a href=\"http://www.fq.math.ca/Scanned/36-4/park.pdf\">Complete Partitions</a>, Fibonacci Quarterly, Vol. 36 (1998), pp. 354-360."], "formula": ["According to the Park link, Theorem 3.7, p. 357f:", "Let D_k(n) be the number of complete partitions of a positive integer n with largest part exactly k.", "D_0(n) = 0 for all n, D_k(0) = 0 for all k, D_1(n)=1 for n>0, and for k>1:", "D_k(n) = D_(k-1)(n-1) + D_k(n-k) if n >= 3*k-1, D_(k-1)(n-1) if 2*k-1 <= n <= 3*k-2, 0 if 1 <= n <= 2*k-2.", "In the following, T(n,k) = D_k(n)."], "example": ["T(8,2) = #{1+1+1+1+1+1+2, 1+1+1+1+2+2, 1+1+2+2+2} = 3;", "T(8,3) = #{1+1+1+1+1+3, 1+1+1+2+3, 1+1+3+3, 1+2+2+3} = 4;", "T(8,4) = #{1+1+1+1+4, 1+1+2+4} = 2;", "T(9,2) = #{+11+1+1+1+1+1+2, 1+1+1+1+1+2+2, 1+1+1+2+2+2, 1+2+2+2+2} = 4;", "T(9,3) = #{1+1+1+1+1+1+3, 1+1+1+1+2+3, 1+1+1+3+3, 1+1+2+2+3, 3,3,2,1} = 5;", "T(9,4) = #{1+1+1+1+1+4, 1+1+1+2+4, 1+1+3+4, 1+2+2+4} = 4;", "T(9,5) = #{1+1+1+1+5, 1+1+2+2+5} = 2.", ". -----------------------------------------------", ".   n |  T(n,k), k = 1 .. [(n+1)/2]  | A126796(n)", ". ----+------------------------------+-----------", ".   1 |  1                           |         1", ".   2 |  1                           |         1", ".   3 |  1 1                         |         2", ".   4 |  1 1                         |         2", ".   5 |  1 2  1                      |         4", ".   6 |  1 2  2                      |         5", ".   7 |  1 3  2  2                   |         8", ".   8 |  1 3  4  2                   |        10", ".   9 |  1 4  5  4  2                |        16", ".  10 |  1 4  6  5  4                |        20", ".  11 |  1 5  8  8  5  4             |        31", ".  12 |  1 5 10 10  8  5             |        39", ".  13 |  1 6 11 14 10  8  5          |        55", ".  14 |  1 6 14 16 16 10  8          |        71", ".  15 |  1 7 16 22 20 16 10  8       |       100", ".  16 |  1 7 18 26 27 20 16 10       |       125", ".  17 |  1 8 21 32 34 31 20 16 10    |       173", ".  18 |  1 8 24 37 42 39 31 20 16    |       218", ".  19 |  1 9 26 46 53 50 39 31 20 16 |       291", ".  20 |  1 9 30 52 66 63 55 39 31 20 |       366"], "mathematica": ["d[k_, n_] := d[k, n] = Which[n == 0 || k == 0, 0, k == 1, 1, n >= 3 k - 1, d[k - 1, n - 1] + d[k, n - k], 2 k - 1 <= n <= 3 k - 2, d[k - 1, n - 1], True, 0]; Table[d[k, n], {n, 17}, {k, Floor[(n + 1)/2]}] // Flatten (* _Michael De Vlieger_, Jul 13 2017 *)"], "program": ["(Haskell)", "import Data.MemoCombinators (memo2, integral, Memo)", "a261036 n k = a261036_tabf !! (n-1) !! (k-1)", "a261036_row n = a261036_tabf !! (n-1)", "a261036_tabf = zipWith (map . flip dMemo) [1..] a122197_tabf where", "   dMemo = memo2 integral integral d", "   d 0 _ = 0", "   d _ 0 = 0", "   d 1 _ = 1", "   d k n | n <= 2 * k - 2 = 0", "         | n <= 3 * k - 2 = dMemo (k - 1) (n - 1)", "         | otherwise      = dMemo (k - 1) (n - 1) + dMemo k (n - k)"], "xref": ["Cf. A008619 (row lengths), A126796 (row sums).", "Cf. A122197."], "keyword": "nonn,tabf,look", "offset": "1,8", "author": "_Reinhard Zumkeller_, Aug 08 2015", "references": 2, "revision": 27, "time": "2017-07-13T20:45:47-04:00", "created": "2015-08-09T00:44:14-04:00"}]}