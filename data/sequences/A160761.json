{"greeting": "Greetings from The On-Line Encyclopedia of Integer Sequences! http://oeis.org/", "query": "id:A160761", "count": 1, "start": 0, "results": [{"number": 160761, "data": "9,9,9,21,21,21,21,21,21,21,21,21,21,45,45,49,45,49,49,45,45,49,49,45,49,45,45,45,49,49,45,49,45,45,49,45,45,45,93,93,105,93,105,105,105,93,105,105,105,105,105,105,93,93,105,105,105,105,105,105,93,105,105,105", "name": "The Kaprekar binary numbers in decimal.", "reference": ["M. Charosh, Some Applications of Casting Out 999...'s, Journal of Recreational Mathematics 14, 1981-82, pp. 111-118", "D. R. Kaprekar, On Kaprekar numbers, J. Rec. Math., 13 (1980-1981), 81-82."], "link": ["Juergen Koeller, <a href=\"http://www.mathematische-basteleien.de/kaprekar.htm\">The Kaprekar Number </a>", "Wikipedia, <a href=\"http://en.wikipedia.org/wiki/Kaprekar_number\">Kaprekar Number</a>", "<a href=\"/index/K#Kaprekar_map\">Index entries for the Kaprekar map</a>"], "formula": ["1. Sort all integers from the number in descending order 2. Sort all integers from the number in ascending order 3. Subtract ascending from descending order to obtain a new number 4. Repeat the steps 1-3 with a new number until a repetitive sequence is obtained or until a zero is obtained. 5. Call the repetitive sequence's number a Kaprekar number, ignore zeros."], "example": ["The number 9 is 1001 in binary. The maximum number using the same number of 0's and one's is found and the minimum number having the same number of 0's and 1's is found to obtain the equation such as 1100 - 0011 = 1001. Repeating the same procedure always gives us the same number and pattern of 0's and 1's. Therefore 9 is one of the Kaprekar numbers. Numbers that end the procedure in 0 are excluded since they are not Kaprekar numbers."], "mathematica": ["nmax = 100; f[n_] := Module[{id, sid, min, max}, id = IntegerDigits[n, 2]; min = FromDigits[sid = Sort[id], 2]; max = FromDigits[Reverse[sid], 2]; max - min]; Reap[Do[If[(fpn = FixedPoint[f, n]) > 0, Sow[fpn]], {n, 1, nmax}]][[2, 1]] (* _Jean-Fran\u00e7ois Alcover_, Apr 23 2017 *)"], "program": ["(Java) class pattern { public static void main(String args[]) { int mem1 = 0; int mem2 =1; for (int i = 1; i<3000; i++) {do { mem1 = mem2; String binaryi = Integer.toBinaryString(i); String binarysort = \"\"; String binaryminimum = \"\"; for (int n = 0; n< binaryi.length(); n++) { String g = binaryi.substring(n,n+1); if (g.equals(\"0\")){ binarysort = binarysort+\"0\"; } else { binarysort = \"1\"+binarysort; binaryminimum = binaryminimum + \"1\"; } } int binrev1 = Integer.parseInt(binarysort , 2); int binrev2 = Integer.parseInt(binaryminimum , 2); int diff = binrev1 - binrev2; mem2 = diff; } while (mem2!=0 && mem2!=mem1); String memtobin = Integer.toBinaryString(mem1); int ones = 0; for (int t = 0; t<memtobin.length();t++){ String o = memtobin.substring(t,t+1); if (o.equals(\"1\")) ones++; } if (memtobin.length()!=ones) System.out.print(mem1+\" \"); } }}"], "xref": ["Cf. A099009, A099010, A090429, A069746, A163205."], "keyword": "nonn,base", "offset": "1,1", "author": "_Damir Olejar_, May 25 2009", "references": 1, "revision": 12, "time": "2017-04-24T00:25:05-04:00", "created": "2010-06-01T03:00:00-04:00"}]}