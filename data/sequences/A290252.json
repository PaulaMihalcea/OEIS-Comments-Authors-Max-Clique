{"greeting": "Greetings from The On-Line Encyclopedia of Integer Sequences! http://oeis.org/", "query": "id:A290252", "count": 1, "start": 0, "results": [{"number": 290252, "data": "1,1,1,1,1,2,2,1,1,3,5,3,5,5,5,1,1,4,9,6,14,16,21,4,14,21,42,9,42,14,14,1,1,5,14,10,28,35,56,10,42,70,168,35,210,70,84,5,42,84,252,56,462,168,252,14,462,210,462,28,462,42,42,1,1,6,20,15,48,64,120,20,90,162,450,90,660,216,300,15,132,288,990,216,2112", "name": "Number of standard tableaux of the integer partition having viabin number n.", "comment": ["The viabin number of an integer partition is defined in the following way. Consider the southeast border of the Ferrers board of the integer partition and consider the binary number obtained by replacing each east step with 1 and each north step, except the last one, with 0. The corresponding decimal form is, by definition, the viabin number of the given integer partition. \"Viabin\" is coined from \"via binary\". For example, consider the integer partition [2,2,2,1]. The southeast border of its Ferrers board yields 10100, leading to the viabin number 20.", "In the first Maple program (due basically to _W. Edwin Clark_) (i) the command vitopart(n) yields the partition having viabin number n (for example, vitopart(9) = [2,1,1]), (ii) the command H(p) yields the product of the hooklengths of the partition p (for example, H([2,1,1]) = 8), (iii) the command ST(n) yields the number of standard tableaux corresponding to the partition having viabin number n."], "link": ["Alois P. Heinz, <a href=\"/A290252/b290252.txt\">Table of n, a(n) for n = 0..16384</a>"], "example": ["a(9) = 3; indeed, the partition with viabin number 9 is [2,1,1], the hooklength of the corresponding Ferrers board are 4,1,2,1 and, consequently, the number of standard tableaux is 4!/(4*2) = 3."], "maple": ["vitopart := proc (n) local L, i, j, N, p, t; N := 2*n; L := ListTools:-Reverse(convert(N, base, 2)); j := 0; for i to nops(L) do if L[i] = 0 then j := j+1; p[j] := numboccur(L[1 .. i], 1) end if end do; sort([seq(p[t], t = 1 .. j)], `>=`) end proc: H := proc (pa) local F, j, p, Q, i, col, a, A; F := proc (x) local i, ct: ct := 0: for i to nops(x) do if 1 < x[i] then ct := ct+1 else  end if end do: ct end proc: for j to nops(pa) do p[1][j] := pa[j] end do: Q[1] := [seq(p[1][j], j = 1 .. nops(pa))]: for i from 2 to pa[1] do for j to F(Q[i-1]) do p[i][j] := Q[i-1][j]-1 end do: Q[i] := [seq(p[i][j], j = 1 .. F(Q[i-1]))] end do: for i to pa[1] do col[i] := [seq(Q[i][j]+nops(Q[i])-j, j = 1 .. nops(Q[i]))] end do: a := proc (i, j) if i <= nops(Q[j]) and j <= pa[1] then Q[j][i]+nops(Q[j])-i else 1 end if end proc: A := matrix(nops(pa), pa[1], a): product(product(A[m, n], n = 1 .. pa[1]), m = 1 .. nops(pa)) end proc: ST := proc (m) options operator, arrow: factorial(add(u, `in`(u, vitopart(m))))/H(vitopart(m)) end proc: seq(ST(q), q = 0 .. 120);", "# second Maple program:", "a:= proc(n) local l, m; m:= n; [0]; while m>0 do `if`(1=", "      irem(m, 2, 'm'), map(x-> x+1, %), [%[], 0]) od: l:=%:", "      (h-> add(i, i=l)!/mul(mul(1+l[i]-j+add(`if`(j>l[k]", "      , 0, 1), k=i+1..h), j=1..l[i]), i=1..h))(nops(l))", "    end:", "seq(a(n), n=0..120);  # _Alois P. Heinz_, Aug 22 2017"], "xref": ["Cf. A290251."], "keyword": "nonn,look", "offset": "0,6", "author": "_Emeric Deutsch_, Aug 22 2017", "references": 2, "revision": 23, "time": "2017-08-23T12:09:22-04:00", "created": "2017-08-22T13:47:40-04:00"}]}